# 정의
MDN에서 정의하길 Closure는 함수와 렉시컬 환경의 조합입니다.<br>
Closure를 이해하려면 먼저 렉시컬 환경에 대해 이해를 해야합니다.
<br><br>
# 렉시컬 환경
Javascript는 렉시컬 환경을 가집니다.<br>
코드가 실행되면 스크립트내에 선언된 변수들은 렉시켤 환경에 올라갑니다.<br><br>
코드로 예시를 들면
```javascript
let x = 10;

function test(y){
		alert(x + y);
}

test(5); // 15;
```
위의 코드가 실행되면 렉시컬 환경이 생성됩니다.<br>
그 렉시컬 환경에는 `x = 10`, `텅빈 test함수` 가 렉시컬 환경에 올라갑니다.<br><br>

이후에 코드가 한줄 한줄 실행되면서 `test(5);`를 만났을 때<br> 
`test함수`에 대한 새로운 렉시컬 환경이 생성되게 되고, 이 렉시컬 환경에는 `y = 5` 가 올라가게 되면서 전역 렉시컬 환경을 참조하는 구조가 만들어지게 됩니다.<br><br>

여기서 말하는 전역 렉시컬 환경은 처음에 만들어진 `x = 10`, `test함수` 가 존재하는 렉시컬 환경을 말합니다.<br><br>

# Closure
클로저는 함수와 렉시컬 환경의 조합입니다.<br>
함수가 생성될 당시의 외부변수를 기억하고 외부함수의 실행이 끝나고 소멸되어도
내부함수가 외부함수의 변수에 접근 할 수 있습니다.<br><br>

위와 비슷한 방식의 코드로 예시를 들면
```javascript
function test(x){
	return function(y){
		return x + y;
	}
}

let run = test(5);

console.log(run(10));
```
위의 코드가 실행되면 `텅빈 test함수`, `run(초기화 안됨)`이 렉시컬 환경에 올라가게 됩니다.<br>
이후에 `test(5);`가 실행되면서 `test함수`에 대한 렉시컬 환경이 생성 되고, `x = 5` 가 올라가게 됩니다.<br>

그리고 `run(10);`이 실행되면 내부 함수인 `익명함수`에 대한 렉시컬 환경이 하나 더 생성되면서 `y = 10`이 올라가게 되고 아래와 같은 구조를 가지게 됩니다.<br><br>

> **(전역 렉시컬 환경)**
`텅빈 test함수`, `run(초기화 안됨)`이 올라간 렉시컬 환경
> 

⬆️ **참조**

> **(test함수 렉시컬 환경)**
`x = 5`가 올라간 렉시컬 환경
> 

⬆️ **참조**

> **(익명함수 렉시컬 환경)**
`y = 10`가 올라간 렉시컬 환경
>
<br>
익명함수부터 시작해서 전역 렉시컬 환경까지 점점 범위를 넓혀가면서 필요한 정보를 찾게 됩니다.<br><br>
정리하자면 return되는 익명함수(내부함수)는 상위함수(외부함수)의 매개변수 x에 접근이 가능하고,
외부함수가 실행 후 소멸시점인 run(10);를 만나게 되어도 x에 접근이 가능해집니다.
<br><br>
그럼 Closure를 왜 사용하는지 적어보자면 보통 처음 프로그래밍을 접하면 변수를 전역으로 선언하는데<br>그렇게 되면 여러곳에서 변수를 공유하기 때문에 오류가 생길 확률이 높습니다.<br><br>
하지만 Closure를 이용해서 변수를 내부로 숨긴다면 객체지향언어에서 private를 사용해서 캡슐화를 통해 정보를 은닉하는 것처럼 Javascript에서는 Closure를 통해서 비슷한 기능을 구현할 수 있습니다.